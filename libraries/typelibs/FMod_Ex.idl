[
	uuid(33F55478-C029-461d-B576-ED1314C0C2D8),
	helpstring("FMod Ex Alpha 0.5 Type Library"),
	version(0.5),
	lcid(0x0409)
]
library FModExAPI {
	[v1_enum]
	enum FModExAPIInfo {
		[helpstring("FMod Ex Type Library by Kevin Gadd (janus@luminance.org)")]
		FMOD_TYPELIB_VERSION = 3,
		[helpstring("For FMod Ex Alpha 0.5")]
		FMOD_TYPELIB_FMOD_VERSION = 50
	};

	[v1_enum,
		helpstring("Error codes.  Returned from every function.")
	]
	enum FMOD_RESULT {
		[helpstring("No errors. ")]
		FMOD_OK,
		[helpstring("Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock / FMOD_Sound_Lock on a streaming Sound). ")]
		FMOD_ERR_BADCOMMAND,
		[helpstring("Cannot call this command after FMOD_System_Init. ")]
		FMOD_ERR_BUSY,
		[helpstring("Error trying to allocate a channel. ")]
		FMOD_ERR_CHANNEL_ALLOC,
		[helpstring("The specified channel has been reused to play another Sound. ")]
		FMOD_ERR_CHANNEL_STOLEN,
		[helpstring("Couldn't find the specified device. ")]
		FMOD_ERR_CDDA_INVALID_DEVICE,
		[helpstring("Neither NTSCSI nor ASPI could be initialised. ")]
		FMOD_ERR_CDDA_DRIVERS,
		[helpstring("An error occurred while initialising the CDDA subSystem. ")]
		FMOD_ERR_CDDA_INIT,
		[helpstring("No audio tracks on the specified disc. ")]
		FMOD_ERR_CDDA_NOAUDIO,
		[helpstring("No CD/DVD devices were found. ")]
		FMOD_ERR_CDDA_NODEVICES, 
		[helpstring("No disc present in the specified drive. ")]
		FMOD_ERR_CDDA_NODISC,
		[helpstring("A CDDA read error occurred. ")]
		FMOD_ERR_CDDA_READ,
		[helpstring("A requested codec was not available. ")]
		FMOD_ERR_CODEC_MISSING,
		[helpstring("A Win32 COM related error occured. COM failed to initialize or a QueryInterface failed meaning a Windows codec or driver was not installed properly. ")]
		FMOD_ERR_COM,
		[helpstring("DSP connection error.  Either the connection caused a cyclic dependancy or the unit issues variable sized reads and tried to connect to a node that was already connected to. ")]
		FMOD_ERR_DSP_CONNECTION,
		[helpstring("DSP connection error.  Couldn't find the DSP unit specified. ")]
		FMOD_ERR_DSP_NOTFOUND,
		[helpstring("DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format.  IE a floating point unit on a PocketPC System. ")]
		FMOD_ERR_DSP_FORMAT,
		[helpstring("DSP error.  Cannot perform this operation while the network is in the middle of running.  This will most likely happen if a connection or disconnection is attempted in a DSP callback. ")]
		FMOD_ERR_DSP_RUNNING,
		[helpstring("Error loading file. ")]
		FMOD_ERR_FILE_BAD,
		[helpstring("Couldn't perform seek operation. ")]
		FMOD_ERR_FILE_COULDNOTSEEK,
		[helpstring("End of file unexpectedly reached while trying to read essential data (truncated data?). ")]
		FMOD_ERR_FILE_EOF,
		[helpstring("File not found. ")]
		FMOD_ERR_FILE_NOTFOUND,
		[helpstring("Unsupported file or audio format. ")]
		FMOD_ERR_FORMAT,
		[helpstring("A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere. ")]
		FMOD_ERR_HTTP,
		[helpstring("The specified resource requires authentication or is forbidden. ")]
		FMOD_ERR_HTTP_ACCESS,
		[helpstring("Proxy authentication is required to access the specified resource. ")]
		FMOD_ERR_HTTP_PROXY_AUTH,
		[helpstring("A HTTP server error occurred. ")]
		FMOD_ERR_HTTP_SERVER_ERROR,
		[helpstring("The HTTP request timed out. ")]
		FMOD_ERR_HTTP_TIMEOUT,
		[helpstring("An error occured that wasnt supposed to.  Contact support. ")]
		FMOD_ERR_INTERNAL,
		[helpstring("An invalid object handle was used. ")]
		FMOD_ERR_INVALID_HANDLE,
		[helpstring("An invalid parameter was passed to this function. ")]
		FMOD_ERR_INVALID_PARAM,
		[helpstring("Not enough memory or resources. ")]
		FMOD_ERR_MEMORY,
		[helpstring("Couldn't connect to the specified host. ")]
		FMOD_ERR_NET_CONNECT,
		[helpstring("A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere. ")]
		FMOD_ERR_NET_SOCKET_ERROR,
		[helpstring("The specified URL couldn't be resolved. ")]
		FMOD_ERR_NET_URL,
		[helpstring("Operation could not be performed because specified Sound is not ready. ")]
		FMOD_ERR_NOTREADY,
		[helpstring("Error initializing output device, but more specifically, the output device is already in use and cannot be reused. ")]
		FMOD_ERR_OUTPUT_ALLOCATED,
		[helpstring("Error creating hardware Sound buffer. ")]
		FMOD_ERR_OUTPUT_CREATEBUFFER,
		[helpstring("A call to a standard Soundcard driver failed, which could possibly mean a bug in the driver. ")]
		FMOD_ERR_OUTPUT_DRIVERCALL,
		[helpstring("Soundcard does not support the minimum features needed for this SoundSystem (16bit stereo output). ")]
		FMOD_ERR_OUTPUT_FORMAT,
		[helpstring("Error initializing output device. ")]
		FMOD_ERR_OUTPUT_INIT,
		[helpstring("FMOD_HARDWARE was specified but the Sound card does not have the resources nescessary to play it. ")]
		FMOD_ERR_OUTPUT_NOHARDWARE,
		[helpstring("Attempted to create a software Sound but no software channels were specified in System::init. ")]
		FMOD_ERR_OUTPUT_NOSOFTWARE,
		[helpstring("Panning only works with mono or stereo Sound sources. ")]
		FMOD_ERR_PAN,
		[helpstring("The specified tag could not be found or there are no tags. ")]
		FMOD_ERR_TAGNOTFOUND,
		[helpstring("This command failed because FMOD_System_Init or FMOD_System_SetDriver was not called. ")]
		FMOD_ERR_UNINITIALIZED,
		[helpstring("A commmand issued was not supported by this object.  Possibly a plugin without certain callbacks specified. ")]
		FMOD_ERR_UNSUPPORTED,
		[helpstring("The version number of this file format is not supported. ")]
		FMOD_ERR_VERSION,
		[helpstring("Something in FMOD hasn't been implemented when it should be! contact support!")]
		FMOD_ERR_UNIMPLEMENTED
	};

	[v1_enum,
		helpstring("These output types are used with System::setOutput/System::getOutput/FMOD_System_SetOutput/FMOD_System_GetOutput, to choose which output method to use.")
	]
	enum FMOD_OUTPUT_TYPE {
		[helpstring("Picks the best output mode for the platform.  This is the default. ")]
		FMOD_OUTPUT_AUTODETECT,
		[helpstring("Win32/WinCE - Windows Multimedia output. ")]
		FMOD_OUTPUT_WINMM,
		[helpstring("Win32       - DirectSound output.  Use this to get EAX Reverb/DX8 FX support. ")]
		FMOD_OUTPUT_DSound,
		[helpstring("Win32       - Low latency ASIO driver. ")]
		FMOD_OUTPUT_ASIO,
		[helpstring("Linux       - Open Sound System output. ")]
		FMOD_OUTPUT_OSS,
		[helpstring("Linux       - Enlightment Sound Daemon output. ")]
		FMOD_OUTPUT_ESD,
		[helpstring("Linux       - Advanced Linux Sound Architecture output. ")]
		FMOD_OUTPUT_ALSA,
		[helpstring("Mac         - Macintosh SoundManager output. ")]
		FMOD_OUTPUT_MAC,
		[helpstring("Xbox        - Native hardware output. ")]
		FMOD_OUTPUT_XBOX,
		[helpstring("PS2         - Native hardware output. ")]
		FMOD_OUTPUT_PS2,
		[helpstring("GameCube    - Native hardware output. ")]
		FMOD_OUTPUT_GC,
		[helpstring("All         - All calls in this mode succeed but make no Sound. ")]
		FMOD_OUTPUT_NOSound,
		[helpstring("All         - Writes output to fmodout.wav by default.  Use System::setOutputFormat / FMOD_System_SetOutputFormat to set the filename. ")]
		FMOD_OUTPUT_WAVWRITER 
	};

	[v1_enum,
		helpstring("")
	]
	enum FMOD_CAPS {
		[helpstring("Device has no special capabilities. ")]
		FMOD_CAPS_NONE                   = 0x00000000,    
		[helpstring("Device supports hardware mixing. ")]
		FMOD_CAPS_HARDWARE               = 0x00000001,    
		[helpstring("Device can do multichannel output, ie greater than 2 channels. ")]
		FMOD_CAPS_OUTPUT_MULTICHANNEL    = 0x00000002,    
		[helpstring("Device can output to 8bit integer PCM. ")]
		FMOD_CAPS_OUTPUT_FORMAT_PCM8     = 0x00000004,    
		[helpstring("Device can output to 16bit integer PCM. ")]
		FMOD_CAPS_OUTPUT_FORMAT_PCM16    = 0x00000008,    
		[helpstring("Device can output to 24bit integer PCM. ")]
		FMOD_CAPS_OUTPUT_FORMAT_PCM24    = 0x00000010,    
		[helpstring("Device can output to 32bit integer PCM. ")]
		FMOD_CAPS_OUTPUT_FORMAT_PCM32    = 0x00000020,    
		[helpstring("Device can output to 32bit floating point PCM. ")]
		FMOD_CAPS_OUTPUT_FORMAT_PCMFLOAT = 0x00000040,    
		[helpstring("Device supports EAX2 reverb. ")]
		FMOD_CAPS_REVERB_EAX2            = 0x00000100,    
		[helpstring("Device supports EAX3 reverb. ")]
		FMOD_CAPS_REVERB_EAX3            = 0x00000200,    
		[helpstring("Device supports I3DL2 reverb. ")]
		FMOD_CAPS_REVERB_I3DL2           = 0x00000400,    
		[helpstring("Device supports some form of limited hardware reverb, maybe parameterless and only selectable by environment. ")]
		FMOD_CAPS_REVERB_LIMITED         = 0x00000800     
	};

	[v1_enum,
		helpstring("These are speaker types defined for use with the System::setSpeakerMode command.")
	]
	enum FMOD_SPEAKERMODE {
		[helpstring("The speakers are monaural. ")]
		FMOD_SPEAKERMODE_MONO,
		[helpstring("The speakers are stereo (default value). ")]
		FMOD_SPEAKERMODE_STEREO,
		[helpstring("5 channel mixing is downmixed to stereo ProLogic output. ")]
		FMOD_SPEAKERMODE_PROLOGIC,
		[helpstring("5 channel mixing is downmixed to stereo ProLogic 2 output. ")]
		FMOD_SPEAKERMODE_PROLOGIC2,
		[helpstring("Dolby Digital / DTS or PCM 5.1 channel output. ")]
		FMOD_SPEAKERMODE_5POINT1 
	};

	[v1_enum,
		helpstring("These are speaker types defined for use with the System::setSpeakerMode command.")
	]
	enum FMOD_SPEAKER {
		[helpstring("Speaker location is unknown ")]
		FMOD_SPEAKER_GENERIC,
		FMOD_SPEAKER_FRONT_LEFT,
		FMOD_SPEAKER_FRONT_RIGHT,
		FMOD_SPEAKER_FRONT_CENTER,
		FMOD_SPEAKER_LOW_FREQUENCY,
		FMOD_SPEAKER_BACK_LEFT,
		FMOD_SPEAKER_BACK_RIGHT,
		FMOD_SPEAKER_FRONT_LEFT_OF_CENTER,
		FMOD_SPEAKER_FRONT_RIGHT_OF_CENTER,
		FMOD_SPEAKER_BACK_CENTER,
		FMOD_SPEAKER_SIDE_LEFT,
		FMOD_SPEAKER_SIDE_RIGHT,
		FMOD_SPEAKER_TOP_CENTER,
		FMOD_SPEAKER_TOP_FRONT_LEFT,
		FMOD_SPEAKER_TOP_FRONT_CENTER,
		FMOD_SPEAKER_TOP_FRONT_RIGHT,
		FMOD_SPEAKER_TOP_BACK_LEFT,
		FMOD_SPEAKER_TOP_BACK_CENTER,
		FMOD_SPEAKER_TOP_BACK_RIGHT
	};

	[v1_enum,
		helpstring("Initialization flags.  Use them with System::init in the flags parameter to change various behaviour.")
	]
	enum FMOD_INITFLAGS	{
		[helpstring("Initialize normally ")]
		FMOD_INIT_NORMAL,
		[helpstring("Output is driven with FMOD_System_Update or System::update. ")]
		FMOD_INIT_NONREALTIME             = 0x00000001,
		[helpstring("For DirectSound output - Sound is not muted when window is out of focus. ")]
		FMOD_INIT_GLOBALFOCUS             = 0x00000002,
		[helpstring("For DirectSound output - 3D commands are batched together and executed at FMOD_System_Update or System::update. ")]
		FMOD_INIT_DSound_DEFERRED         = 0x00000004,
		[helpstring("FMOD will treat +X as left, +Y as up and +Z as forwards. ")]
		FMOD_INIT_3D_RIGHTHANDED          = 0x00000008,
		[helpstring("PS2 only - Disable reverb on CORE 0 to regain SRAM. ")]
		FMOD_INIT_PS2_DISABLECORE0REVERB  = 0x00000010,
		[helpstring("PS2 only - Disable reverb on CORE 1 to regain SRAM. ")]
		FMOD_INIT_PS2_DISABLECORE1REVERB 
	};

	[v1_enum,
		helpstring("These definitions describe the type of song being played.")
	]
	enum FMOD_SOUND_TYPE {
		[helpstring("Unitialized / unknown ")]
		FMOD_SOUND_TYPE_NONE,
		[helpstring("Protracker / Fasttracker ")]
		FMOD_SOUND_TYPE_MOD,
		[helpstring("ScreamTracker 3 ")]
		FMOD_SOUND_TYPE_S3M,
		[helpstring("FastTracker 2 ")]
		FMOD_SOUND_TYPE_XM,
		[helpstring("Impulse Tracker. ")]
		FMOD_SOUND_TYPE_IT,
		[helpstring("MIDI ")]
		FMOD_SOUND_TYPE_MIDI,
		[helpstring("Microsoft WAV ")]
		FMOD_SOUND_TYPE_WAV,
		[helpstring("MP2/MP3 ")]
		FMOD_SOUND_TYPE_MPEG,
		[helpstring("Ogg vorbis ")]
		FMOD_SOUND_TYPE_OGGVORBIS,
		[helpstring("Ogg vorbis Integer codec ")]
		FMOD_SOUND_TYPE_TREMOR,
		[helpstring("AIFF ")]
		FMOD_SOUND_TYPE_AIFF,
		[helpstring("Microsoft Advanced Systems Format (ie WMA/ASF/WMV) ")]
		FMOD_SOUND_TYPE_ASF,
		[helpstring("FLAC lossless codec ")]
		FMOD_SOUND_TYPE_FLAC,
		[helpstring("Digital CD audio ")]
		FMOD_SOUND_TYPE_CDDA,
		[helpstring("FMOD Sample Bank ")]
		FMOD_SOUND_TYPE_FSB,
		[helpstring("Raw PCM data ")]
		FMOD_SOUND_TYPE_RAW,
		[helpstring("User created Sound ")]
		FMOD_SOUND_TYPE_USER 
	};

	[v1_enum,
		helpstring("These definitions describe the native format of the hardware or software buffer that will be used.")
	]
	enum FMOD_SOUND_FORMAT {
		[helpstring("Unitialized / unknown ")]
		FMOD_SOUND_FORMAT_NONE,
		[helpstring("8bit integer PCM data ")]
		FMOD_SOUND_FORMAT_PCM8,
		[helpstring("16bit integer PCM data  ")]
		FMOD_SOUND_FORMAT_PCM16,
		[helpstring("24bit integer PCM data  ")]
		FMOD_SOUND_FORMAT_PCM24,
		[helpstring("32bit integer PCM data  ")]
		FMOD_SOUND_FORMAT_PCM32,
		[helpstring("32bit floating point PCM data  ")]
		FMOD_SOUND_FORMAT_PCMFLOAT,
		[helpstring("Compressed GameCube DSP data ")]
		FMOD_SOUND_FORMAT_GCADPCM,
		[helpstring("Compressed XBox ADPCM data ")]
		FMOD_SOUND_FORMAT_XADPCM,
		[helpstring("Compressed PlayStation 2 ADPCM data ")]
		FMOD_SOUND_FORMAT_VAG 
	};

	[v1_enum,
		helpstring("Sound description bitfields, OR them together for loading and describing Sounds.")
	]
	enum FMOD_MODE
	{
		[helpstring("default ")]
		FMOD_DEFAULT             = 0x00000000,
		[helpstring("For non looping Sounds. ")]
		FMOD_LOOP_OFF            = 0x00000001,
		[helpstring("For forward looping Sounds. ")]
		FMOD_LOOP_NORMAL         = 0x00000002,
		[helpstring("For bidirectional looping Sounds. (only works on software mixed static Sounds). ")]
		FMOD_LOOP_BIDI           = 0x00000004,
		[helpstring("Ignores any 3d processing.  Overrides FMOD_3D. ")]
		FMOD_2D                  = 0x00000008,
		[helpstring("Makes the Sound positionable in 3D.  Overrides FMOD_2D. (default). ")]
		FMOD_3D                  = 0x00000010,
		[helpstring("Makes Sound reside in software (default). ")]
		FMOD_SOFTWARE            = 0x00000020,
		[helpstring("Attempts to make Sounds use hardware acceleration. Overrides FMOD_SOFTWARE. ")]
		FMOD_HARDWARE            = 0x00000040,
		[helpstring("Decompress at runtime, streaming from the source provided (standard stream) ")]
		FMOD_CREATESTREAM        = 0x00000080,
		[helpstring("Decompress at loadtime, and load into Sound memory (static sample) ")]
		FMOD_CREATESTATIC        = 0x00000100,
		[helpstring("Decompress at runtime, after loading into memory first. ")]
		FMOD_CREATESTATICSTREAM  = 0x00000200,
		[helpstring("Opens a user created static sample. ")]
		FMOD_CREATEUSER          = 0x00000400,
		[helpstring("To create a Sound as a recording Sound. ")]
		FMOD_OPENRECORD          = 0x00000800,
		[helpstring("\"name_or_data\" will be interpreted as a pointer to memory instead of filename for creating Sounds. ")]
		FMOD_OPENMEMORY          = 0x00001000,
		[helpstring("Will ignore file format and treat as raw pcm.  User may need to declare if data is FMOD_SIGNED or FMOD_ ")]
		FMOD_OPENRAW             = 0x00002000,
		[helpstring("Just open the file, dont prebuffer or read.  Good for fast opens for info, or when Sound::readData is to be used. ")]
		FMOD_OPENONLY            = 0x00004000,
		[helpstring("For FMOD_CreateSound - for accurate FMOD_Sound_GetLengthMs/FMOD_Channel_SetTime.  ")]
		FMOD_MPEGACCURATE        = 0x00008000,
		[helpstring("For FMODCE only - Decodes mpeg Sounds using a lower quality decode, but faster execution ")]
		FMOD_MPEGHALFRATE        = 0x00010000,
		[helpstring("For opening Sounds asyncronously, return value from open function must be polled for when it is ready. ")]
		FMOD_NONBLOCKING         = 0x00020000,
		[helpstring("Unique Sound, can only be played one at a time ")]
		FMOD_UNIQUE              = 0x00040000,
		[helpstring("Make the Sound's position, velocity and orientation relative to the listener's position, velocity and orientation ")]
		FMOD_3D_HEADRELATIVE     = 0x00080000,
		[helpstring("For CDDA Sounds only - use ASPI instead of NTSCSI to access the specified CD/DVD device. ")]
		FMOD_CDDA_FORCEASPI      = 0x00100000,
		[helpstring("For CDDA Sounds only - perform jitter correction. Jitter correction helps produce a more accurate CDDA stream at the cost of more CPU time. ")]
		FMOD_CDDA_JITTERCORRECT  = 0x00200000,

		[helpstring("FMOD_NORMAL is a default Sound type.  Loop off, 16bit mono, signed, not hardware accelerated, and 3D.")]
		FMOD_NORMAL				= (FMOD_HARDWARE | FMOD_LOOP_OFF | FMOD_2D)
	};

	[v1_enum,
		helpstring("These values describe what state a Sound is in after FMOD_NONBLOCKING has been used to open it.")
	]
	enum FMOD_OPENSTATE	{
		[helpstring("Opened and ready to play ")]
		FMOD_OPENSTATE_READY = 0,
		[helpstring("Initial load in progress ")]
		FMOD_OPENSTATE_LOADING,
		[helpstring("SubSound loading in progress ")]
		FMOD_OPENSTATE_LOADINGSUBSound,
		[helpstring("Failed to open - file not found, out of memory etc. ")]
		FMOD_OPENSTATE_ERROR,
		[helpstring("Connecting to remote host (internet Sounds only) ")]
		FMOD_OPENSTATE_CONNECTING,
		[helpstring("Buffering data ")]
		FMOD_OPENSTATE_BUFFERING
	};

	[v1_enum,
		helpstring("These callback types are used with Channel::setCallback.")
	]
	enum FMOD_CHANNEL_CALLBACK_TYPE {
		FMOD_CHANNEL_CALLBACK_END,
		FMOD_CHANNEL_CALLBACK_WAVSYNC,
		FMOD_CHANNEL_CALLBACK_MODZXX,
		FMOD_CHANNEL_CALLBACK_MODROW,
		FMOD_CHANNEL_CALLBACK_MODORDER,
		FMOD_CHANNEL_CALLBACK_MODINST,
		[helpstring("OR this flag with one of the above to make it callback at mix time, not at audible output time ")]
		FMOD_CHANNEL_CALLBACK_MIXTIME 
	};

	[v1_enum,
		helpstring("List of tag types that could be stored within a Sound.  These include id3 tags, metadata from netstreams and vorbis/asf data.")
	]
	enum FMOD_TAGTYPE {
		FMOD_TAGTYPE_UNKNOWN = 0,
		FMOD_TAGTYPE_ID3V1,
		FMOD_TAGTYPE_ID3V2,
		FMOD_TAGTYPE_VORBISCOMMENT,
		FMOD_TAGTYPE_SHOUTCAST,
		FMOD_TAGTYPE_ICECAST,
		FMOD_TAGTYPE_ASF,
		FMOD_TAGTYPE_FMOD,
		FMOD_TAGTYPE_USER
	};

	[v1_enum,
		helpstring("List of data types that can be returned by Sound::getTag")
	]
	enum FMOD_TAGDATATYPE {
		FMOD_TAGDATATYPE_BINARY = 0,
		FMOD_TAGDATATYPE_INT,
		FMOD_TAGDATATYPE_FLOAT,
		FMOD_TAGDATATYPE_STRING,
		FMOD_TAGDATATYPE_STRING_UTF16,
		FMOD_TAGDATATYPE_STRING_UTF16BE,
		FMOD_TAGDATATYPE_STRING_UTF8,
		FMOD_TAGDATATYPE_CDTOC
	};

	[v1_enum,
		helpstring("")
	]
	enum FMOD_REVERB_FLAGS {
		[helpstring("'EnvSize' affects reverberation decay time ")]
		FMOD_REVERB_FLAGS_DECAYTIMESCALE = 0x00000001, 
		[helpstring("'EnvSize' affects reflection level ")]
		FMOD_REVERB_FLAGS_REFLECTIONSSCALE = 0x00000002, 
		[helpstring("'EnvSize' affects initial reflection delay time ")]
		FMOD_REVERB_FLAGS_REFLECTIONSDELAYSCALE = 0x00000004, 
		[helpstring("'EnvSize' affects reflections level ")]
		FMOD_REVERB_FLAGS_REVERBSCALE = 0x00000008, 
		[helpstring("'EnvSize' affects late reverberation delay time ")]
		FMOD_REVERB_FLAGS_REVERBDELAYSCALE = 0x00000010, 
		[helpstring("AirAbsorptionHF affects DecayHFRatio ")]
		FMOD_REVERB_FLAGS_DECAYHFLIMIT = 0x00000020, 
		[helpstring("'EnvSize' affects echo time ")]
		FMOD_REVERB_FLAGS_ECHOTIMESCALE = 0x00000040, 
		[helpstring("'EnvSize' affects modulation time ")]
		FMOD_REVERB_FLAGS_MODULATIONTIMESCALE = 0x00000080, 
		FMOD_REVERB_FLAGS_DEFAULT = (FMOD_REVERB_FLAGS_DECAYTIMESCALE |
			FMOD_REVERB_FLAGS_REFLECTIONSSCALE |
			FMOD_REVERB_FLAGS_REFLECTIONSDELAYSCALE |
			FMOD_REVERB_FLAGS_REVERBSCALE |
			FMOD_REVERB_FLAGS_REVERBDELAYSCALE |
			FMOD_REVERB_FLAGS_DECAYHFLIMIT)
	};

	[v1_enum,
		helpstring("Values for the Flags member of the FMOD_REVERB_CHANNELPROPERTIES structure.")
	]
	enum FMOD_REVERB_CHANNELFLAGS {
		[helpstring("Automatic setting of 'Direct'  due to distance from listener ")]
		FMOD_REVERB_CHANNELFLAGS_DIRECTHFAUTO = 0x00000001, 
		[helpstring("Automatic setting of 'Room'  due to distance from listener ")]
		FMOD_REVERB_CHANNELFLAGS_ROOMAUTO = 0x00000002, 
		[helpstring("Automatic setting of 'RoomHF' due to distance from listener ")]
		FMOD_REVERB_CHANNELFLAGS_ROOMHFAUTO = 0x00000004, 
		FMOD_REVERB_CHANNELFLAGS_DEFAULT = (FMOD_REVERB_CHANNELFLAGS_DIRECTHFAUTO |
			FMOD_REVERB_CHANNELFLAGS_ROOMAUTO |
			FMOD_REVERB_CHANNELFLAGS_ROOMHFAUTO)
	};

	[v1_enum,
		helpstring("Miscellaneous values for FMOD functions.")
	]
	enum FMOD_MISC_VALUES {
		[helpstring("Value to play on any free channel.")]
		FMOD_CHANNEL_FREE = -1,
		[helpstring("For a channel index , this flag will affect ALL channels available!  Not supported by every function.")]
		FMOD_CHANNEL_ALL = -2
	};

	[v1_enum,
		helpstring("These definitions can be used for creating FMOD defined special effects or DSP units.")
	]
	enum FMOD_DSP_ID {
		[helpstring("This unit does nothing but take inputs and mix them together then feed the result to the Soundcard unit. ")]
		FMOD_DSP_ID_MIXER,
		[helpstring("This unit generates sine/square/saw/triangle or noise tones. ")]
		FMOD_DSP_ID_OSCILLATOR
	};

	[v1_enum,
		helpstring("These definitions describe whether the unit is a generator, resampler or a filter.")
	]
	enum FMOD_DSP_TYPE {
		[helpstring("This is a unit type that processes incoming data ")]
		FMOD_DSP_TYPE_FILTER,
		[helpstring("This is a unit type that generates data ")]
		FMOD_DSP_TYPE_GENERATOR,
		[helpstring("This is a unit type that resamples data ")]
		FMOD_DSP_TYPE_RESAMPLER,
		[helpstring("This is a unit type that only receives data ")]
		FMOD_DSP_TYPE_SoundCARD,
		[helpstring("This is a unit type that only reads wave data ")]
		FMOD_DSP_TYPE_WAVETABLE
	};

	[v1_enum,
		helpstring("Oscillator types for the FMOD_DSP_OSCILLATOR filter.")
	]
	enum FMOD_DSP_OSCILLATOR_TYPE {
		FMOD_DSP_OSCILLATOR_SINE,
		FMOD_DSP_OSCILLATOR_SQUARE,
		FMOD_DSP_OSCILLATOR_SAWUP,
		FMOD_DSP_OSCILLATOR_SAWDOWN,
		FMOD_DSP_OSCILLATOR_TRIANGLE,
		FMOD_DSP_OSCILLATOR_NOISE            
	};

	struct FMOD_TAG {
		[helpstring("The type of this tag. ")]
		enum FMOD_TAGTYPE      type;
		[helpstring("The type of data that this tag contains ")]
		enum FMOD_TAGDATATYPE  datatype;
		[string, helpstring("The name of this tag i.e. \"TITLE\", \"ARTIST\" etc. ")]
		char             *name;
		[helpstring("Pointer to the tag data - it's format is determined by the datatype member ")]
		int             data;
		[helpstring("Length of the data contained in this tag ")]
		int      datalen;
		[helpstring("True if this tag has been updated since last being accessed with Sound::getTag ")]
		int         updated;
	};

	struct FMOD_CDTOC {
		[helpstring("The number of tracks on the CD ")]
		int numtracks;
		[helpstring("The start offset of each track in minutes ")]
		int min[100];
		[helpstring("The start offset of each track in seconds ")]
		int sec[100];
		[helpstring("The start offset of each track in frames ")]
		int frame[100];
	};

	struct FMOD_REVERB_PROPERTIES {                                   
		[helpstring("0     , 25    , 0      , sets all listener properties (win32 only) ")]
		int Environment;
		[helpstring("1.0   , 100.0 , 7.5    , environment size in meters (win32 only) ")]
		float   EnvSize;
		[helpstring("0.0   , 1.0   , 1.0    , environment diffusion (win32/xbox) ")]
		float   EnvDiffusion;
		[helpstring("-10000, 0     , -1000  , room effect level (at mid frequencies) (win32/xbox) ")]
		int          Room;
		[helpstring("-10000, 0     , -100   , relative room effect level at high frequencies (win32/xbox) ")]
		int          RoomHF;
		[helpstring("-10000, 0     , 0      , relative room effect level at low frequencies (win32 only) ")]
		int          RoomLF;
		[helpstring("0.1   , 20.0  , 1.49   , reverberation decay time at mid frequencies (win32/xbox) ")]
		float   DecayTime;
		[helpstring("0.1   , 2.0   , 0.83   , high-frequency to mid-frequency decay time ratio (win32/xbox) ")]
		float   DecayHFRatio;
		[helpstring("0.1   , 2.0   , 1.0    , low-frequency to mid-frequency decay time ratio (win32 only) ")]
		float   DecayLFRatio;
		[helpstring("-10000, 1000  , -2602  , early reflections level relative to room effect (win32/xbox) ")]
		int          Reflections;
		[helpstring("0.0   , 0.3   , 0.007  , initial reflection delay time (win32/xbox) ")]
		float   ReflectionsDelay;
		[helpstring(",       , [0,0,0], early reflections panning vector (win32 only) ")]
		float   ReflectionsPan[3];
		[helpstring("-10000, 2000  , 200    , late reverberation level relative to room effect (win32/xbox) ")]
		int          Reverb;
		[helpstring("0.0   , 0.1   , 0.011  , late reverberation delay time relative to initial reflection (win32/xbox) ")]
		float   ReverbDelay;
		[helpstring(",       , [0,0,0], late reverberation panning vector (win32 only) ")]
		float   ReverbPan[3];
		[helpstring(".075  , 0.25  , 0.25   , echo time (win32 only) ")]
		float   EchoTime;
		[helpstring("0.0   , 1.0   , 0.0    , echo depth (win32 only) ")]
		float   EchoDepth;
		[helpstring("0.04  , 4.0   , 0.25   , modulation time (win32 only) ")]
		float   ModulationTime;
		[helpstring("0.0   , 1.0   , 0.0    , modulation depth (win32 only) ")]
		float   ModulationDepth;
		[helpstring("-100  , 0.0   , -5.0   , change in level per meter at high frequencies (win32 only) ")]
		float   AirAbsorptionHF;
		[helpstring("1000.0, 20000 , 5000.0 , reference high frequency (hz) (win32/xbox) ")]
		float   HFReference;
		[helpstring("20.0  , 1000.0, 250.0  , reference low frequency (hz) (win32 only) ")]
		float   LFReference;
		[helpstring("0.0   , 10.0  , 0.0    , like FMOD_3D_Listener_SetRolloffFactor but for room effect (win32/xbox) ")]
		float   RoomRolloffFactor;
		[helpstring("0.0   , 100.0 , 100.0  , Value that controls the echo density in the late reverberation decay. (xbox only) ")]
		float   Diffusion;
		[helpstring("0.0   , 100.0 , 100.0  , Value that controls the modal density in the late reverberation decay (xbox only) ")]
		float   Density;
		[helpstring("FMOD_REVERB_FLAGS - modifies the behavior of above properties (win32 only) ")]
		enum FMOD_REVERB_FLAGS Flags;
	};

	struct FMOD_REVERB_CHANNELPROPERTIES {                                   
		[helpstring("-10000, 1000,  0,    direct path level (at low and mid frequencies) (win32/xbox) ")]
		int         Direct;
		[helpstring("-10000, 0,     0,    relative direct path level at high frequencies (win32/xbox) ")]
		int         DirectHF;
		[helpstring("-10000, 1000,  0,    room effect level (at low and mid frequencies) (win32/xbox) ")]
		int         Room;
		[helpstring("-10000, 0,     0,    relative room effect level at high frequencies (win32/xbox) ")]
		int         RoomHF;
		[helpstring("-10000, 0,     0,    main obstruction control (attenuation at high frequencies)  (win32/xbox) ")]
		int         Obstruction;
		[helpstring("0.0,    1.0,   0.0,  obstruction low-frequency level re. main control (win32/xbox) ")]
		float  ObstructionLFRatio;
		[helpstring("-10000, 0,     0,    main occlusion control (attenuation at high frequencies) (win32/xbox) ")]
		int         Occlusion;
		[helpstring("0.0,    1.0,   0.25, occlusion low-frequency level re. main control (win32/xbox) ")]
		float  OcclusionLFRatio;
		[helpstring("0.0,    10.0,  1.5,  relative occlusion control for room effect (win32) ")]
		float  OcclusionRoomRatio;
		[helpstring("0.0,    10.0,  1.0,  relative occlusion control for direct path (win32) ")]
		float  OcclusionDirectRatio;
		[helpstring("-10000, 0,     0,    main exlusion control (attenuation at high frequencies) (win32) ")]
		int         Exclusion;
		[helpstring("0.0,    1.0,   1.0,  exclusion low-frequency level re. main control (win32) ")]
		float  ExclusionLFRatio;
		[helpstring("-10000, 0,     0,    outside Sound cone level at high frequencies (win32) ")]
		int         OutsideVolumeHF;
		[helpstring("0.0,    10.0,  0.0,  like DS3D flDopplerFactor but per source (win32) ")]
		float  DopplerFactor;
		[helpstring("0.0,    10.0,  0.0,  like DS3D flRolloffFactor but per source (win32) ")]
		float  RolloffFactor;
		[helpstring("0.0,    10.0,  0.0,  like DS3D flRolloffFactor but for room effect (win32/xbox) ")]
		float  RoomRolloffFactor;
		[helpstring("0.0,    10.0,  1.0,  multiplies AirAbsorptionHF member of FMOD_REVERB_PROPERTIES (win32) ")]
		float  AirAbsorptionFactor;
		[helpstring("FMOD_REVERB_CHANNELFLAGS - modifies the behavior of properties (win32) ")]
		enum FMOD_REVERB_CHANNELFLAGS         Flags;
	};

	struct FMOD_DSP_DESCRIPTION {
		[string, helpstring("Name of the unit to be displayed in the network ")]
		const char                 *name;
		[helpstring("Is it a filter / generator or other type of unit?  See the FMOD_DSP_TYPE enum list to find out which type of unit you want to create, and what the limitations of each are. ")]
		enum FMOD_DSP_TYPE               type;
		[helpstring("FMOD_DSP_TYPE_GENERATOR type only.  Generator format - 8,16,24,32 bit etc.  FMOD_DSP_TYPE_FILTER is always FMOD_SOUND_FORMAT_PCMFLOAT ")]
		enum FMOD_SOUND_FORMAT           format;
		[helpstring("Number of channels.  Use 0 to process whatever number of channels is currently in the network.  >0 would be mostly used if the unit is a fixed format generator and not a filter. ")]
		int                         channels;
		[helpstring("Read callback.  Processing is done here ")]
		int       read_callback;
		[helpstring("Seek callback.  This is called if the unit becomes virtualized and needs to simply update positions etc. ")]
		int       seek_callback;
		[helpstring("This is called when the user calls FMOD::DSP::setParameters ")]
		int   setparameters_callback;
		[helpstring("This is called when the user calls FMOD::DSP::getParameters ")]
		int   getparameters_callback;
		[helpstring("Reserved by FMOD.  Set to 0 ")]
		int                         reserved;
	};

	struct FMOD_DSP_PARAM_OSCILLATOR {
		[helpstring("Waveform type, see FMOD_DSP_OSCILLATOR_TYPE ")]
		enum FMOD_DSP_OSCILLATOR_TYPE type;
		[helpstring("Frequency of the sinewave ")]
		float               ratehz;
		[helpstring("0 = Soundcard's rate (default).  Use other values to alter the unit's output frequency ")]
		int                      outputfrequency;
	};

	struct FMOD_VECTOR {
		float x, y, z;
	};

	[dllname("FModEx.DLL")]
	module Memory {
		[entry("FMOD_Memory_Initialize")]
		enum FMOD_RESULT _cdecl Initialize(void *poolmem_ptr, int poollen, int useralloc_callback, int userrealloc_callback, int userfree_callback);
		[entry("FMOD_Memory_GetStats")]
		enum FMOD_RESULT _cdecl GetStats([out] int *currentalloced, [out] int *maxalloced);
	}

	[dllname("FModEX.DLL")]
	module System {
		[entry("FMOD_System_Create")]
		enum FMOD_RESULT _cdecl Create([out] int *System);
		[entry("FMOD_System_Release")]
		enum FMOD_RESULT _cdecl Release(int System);

		[entry("FMOD_System_SetOutput")]
		enum FMOD_RESULT _cdecl SetOutput (int System, enum FMOD_OUTPUT_TYPE output);
		[entry("FMOD_System_GetOutput")]
		enum FMOD_RESULT _cdecl GetOutput (int System, [out] enum FMOD_OUTPUT_TYPE *output);
		[entry("FMOD_System_SetOutputFormat")]
		enum FMOD_RESULT _cdecl SetOutputFormat (int System, int samplerate, enum FMOD_SOUND_FORMAT format, int numchannels, void *extradata);
		[entry("FMOD_System_GetOutputFormat")]
		enum FMOD_RESULT _cdecl GetOutputFormat (int System, [out] int *samplerate, [out] enum FMOD_SOUND_FORMAT *format, [out] int *numchannels, [out] int *extradata_ptr);
		[entry("FMOD_System_GetNumDrivers")]
		enum FMOD_RESULT _cdecl GetNumDrivers (int System, [out] int *numdrivers);
		[entry("FMOD_System_GetDriverName")]
		enum FMOD_RESULT _cdecl GetDriverName (int System, int id, [out, string] char *name, int namelen);
		[entry("FMOD_System_GetDriverCaps")]
		enum FMOD_RESULT _cdecl GetDriverCaps (int System, int id, [out] enum FMOD_CAPS *caps, [out] int *minfrequency, [out] int *maxfrequency);
		[entry("FMOD_System_SetDriver")]
		enum FMOD_RESULT _cdecl SetDriver (int System, int driver);
		[entry("FMOD_System_GetDriver")]
		enum FMOD_RESULT _cdecl GetDriver (int System, [out] int *driver);
		[entry("FMOD_System_SetDSPBufferSize")]
		enum FMOD_RESULT _cdecl SetDSPBufferSize (int System, int bufferlength, int numbuffers);
		[entry("FMOD_System_GetDSPBufferSize")]
		enum FMOD_RESULT _cdecl GetDSPBufferSize (int System, [out] int *bufferlength, [out] int *numbuffers);
		[entry("FMOD_System_SetMinMaxHWChannels")]
		enum FMOD_RESULT _cdecl SetMinMaxHWChannels (int System, int min, int max);
		[entry("FMOD_System_SetFileSystem")]
		enum FMOD_RESULT _cdecl SetFileSystem (int System, int useropen_callback, int userclose_callback, int userread_callback, int userseek_callback, int usertell_callback);
		[entry("FMOD_System_SetPluginPath")]
		enum FMOD_RESULT _cdecl SetPluginPath (int System, [string] const char *path);

		[entry("FMOD_System_Init")]
		enum FMOD_RESULT _cdecl Init (int System, int maxchannels, int maxsoftwarechannels, enum FMOD_INITFLAGS flags, int hwnd);
		[entry("FMOD_System_Close")]
		enum FMOD_RESULT _cdecl Close (int System);

		[entry("FMOD_System_LoadPlugin")]
		enum FMOD_RESULT _cdecl LoadPlugin (int System, [string] const char *filename);

		[entry("FMOD_System_Update")]
		enum FMOD_RESULT _cdecl Update (int System);
		[entry("FMOD_System_SetSpeakerMode")]
		enum FMOD_RESULT _cdecl SetSpeakerMode (int System, enum FMOD_SPEAKERMODE speakermode);
		[entry("FMOD_System_GetSpeakerMode")]
		enum FMOD_RESULT _cdecl GetSpeakerMode (int System, [out] enum FMOD_SPEAKERMODE *speakermode);
		[entry("FMOD_System_SetMasterVolume")]
		enum FMOD_RESULT _cdecl SetMasterVolume (int System, int volume);
		[entry("FMOD_System_GetMasterVolume")]
		enum FMOD_RESULT _cdecl GetMasterVolume (int System, [out] int *volume);

		[entry("FMOD_System_Set3DSettings")]
		enum FMOD_RESULT _cdecl Set3DSettings (int System, float dopplerscale, float distancefactor, float rolloffscale);
		[entry("FMOD_System_Get3DSettings")]
		enum FMOD_RESULT _cdecl Get3DSettings (int System, [out] float *dopplerscale, [out] float *distancefactor, [out] float *rolloffscale);
		[entry("FMOD_System_Set3DNumListeners")]
		enum FMOD_RESULT _cdecl Set3DNumListeners (int System, int numlisteners);
		[entry("FMOD_System_Get3DNumListeners")]
		enum FMOD_RESULT _cdecl Get3DNumListeners (int System, [out] int *numlisteners);
		[entry("FMOD_System_Set3DListenerAttributes")]
		enum FMOD_RESULT _cdecl Set3DListenerAttributes (int System, int listener, const struct FMOD_VECTOR *pos, const struct FMOD_VECTOR *vel, const struct FMOD_VECTOR *forward, const struct FMOD_VECTOR *up);
		[entry("FMOD_System_Get3DListenerAttributes")]
		enum FMOD_RESULT _cdecl Get3DListenerAttributes (int System, int listener, [out] struct FMOD_VECTOR *pos, [out] struct FMOD_VECTOR *vel, [out] struct FMOD_VECTOR *forward, [out] struct FMOD_VECTOR *up);

		[entry("FMOD_System_SetFileBufferSize")]
		enum FMOD_RESULT _cdecl SetFileBufferSize (int System, int sizebytes);
		[entry("FMOD_System_GetFileBufferSize")]
		enum FMOD_RESULT _cdecl GetFileBufferSize (int System, [out] int *sizebytes);
		[entry("FMOD_System_SetStreamBufferSize")]
		enum FMOD_RESULT _cdecl SetStreamBufferSize (int System, int ms);
		[entry("FMOD_System_GetStreamBufferSize")]
		enum FMOD_RESULT _cdecl GetStreamBufferSize (int System, [out] int *ms);

		[entry("FMOD_System_GetVersion")]
		enum FMOD_RESULT _cdecl GetVersion (int System, [out] int *version);
		[entry("FMOD_System_GetOutputHandle")]
		enum FMOD_RESULT _cdecl GetOutputHandle (int System, [out] int *handle_ptr);
		[entry("FMOD_System_GetNumHWChannels")]
		enum FMOD_RESULT _cdecl GetNumHWChannels (int System, [out] int *numhw3dchannels, [out] int *numhw2dchannels, [out] int *totalchannels);
		[entry("FMOD_System_GetChannelsPlaying")]
		enum FMOD_RESULT _cdecl GetChannelsPlaying (int System, [out] int *Channels);
		[entry("FMOD_System_GetCPUUsage")]
		enum FMOD_RESULT _cdecl GetCPUUsage (int System, [out] float *cpuusage);
		[entry("FMOD_System_GetNumCDROMDrives")]
		enum FMOD_RESULT _cdecl GetNumCDROMDrives (int System, [out] int *numdrives);
		[entry("FMOD_System_GetCDROMDriveName")]
		enum FMOD_RESULT _cdecl GetCDROMDriveName (int System, int drive, [out, string] char *drivename, int drivenamelen, [out, string] char *scsiname, int scsinamelen, [out, string] char *devicename, int devicenamelen);

		[entry("FMOD_System_CreateSound")]
		enum FMOD_RESULT _cdecl CreateSound (int System, [string] const char *name, enum FMOD_MODE flags, [out] int *Sound);
		[entry("FMOD_System_CreateSoundEx")]
		enum FMOD_RESULT _cdecl CreateSoundEx (int System, [string] const char *name_or_data, enum FMOD_MODE flags, int dataoffset, int datalength, int Channels, int defaultfrequency, enum FMOD_SOUND_FORMAT format, int initialsubSound, int numsubSounds, [out] int *Sound);
		[entry("FMOD_System_CreateDSP")]
		enum FMOD_RESULT _cdecl CreateDSP (int System, struct FMOD_DSP_DESCRIPTION *description, [out] int *dsp);
		[entry("FMOD_System_CreateDSPByID")]
		enum FMOD_RESULT _cdecl CreateDSPByID (int System, enum FMOD_DSP_ID type, [out] int *dsp);

		[entry("FMOD_System_PlaySound")]
		enum FMOD_RESULT _cdecl PlaySound (int System, int Channelid, int Sound, int paused, [in, out] int *Channel);
		[entry("FMOD_System_GetChannel")]
		enum FMOD_RESULT _cdecl GetChannel (int System, int Channelid, [out] int *Channel);

		[entry("FMOD_System_SetReverbProperties")]
		enum FMOD_RESULT _cdecl SetReverbProperties (int System, const struct FMOD_REVERB_PROPERTIES *prop);
		[entry("FMOD_System_GetReverbProperties")]
		enum FMOD_RESULT _cdecl GetReverbProperties (int System, [out] struct FMOD_REVERB_PROPERTIES *prop);

		[entry("FMOD_System_GetNumDSPTypes")]
		enum FMOD_RESULT _cdecl GetNumDSPTypes (int System, [out] int *numdsptypes);
		[entry("FMOD_System_GetDSP")]
		enum FMOD_RESULT _cdecl GetDSP (int System, int index, [out] struct FMOD_DSP_DESCRIPTION *description);
		[entry("FMOD_System_GetDSPHead")]
		enum FMOD_RESULT _cdecl GetDSPHead (int System, [out] [out] int *dsp);

		[entry("FMOD_System_SetRecordDriver")]
		enum FMOD_RESULT _cdecl SetRecordDriver (int System, int driver);
		[entry("FMOD_System_GetRecordDriver")]
		enum FMOD_RESULT _cdecl GetRecordDriver (int System, [out] int *driver);
		[entry("FMOD_System_GetRecordNumDrivers")]
		enum FMOD_RESULT _cdecl GetRecordNumDrivers (int System, [out] int *numdrivers);
		[entry("FMOD_System_GetRecordDriverName")]
		enum FMOD_RESULT _cdecl GetRecordDriverName (int System, int id, [out, string] char *name, int namelen);

		[entry("FMOD_System_SetProxy")]
		enum FMOD_RESULT _cdecl SetProxy (int System, const char *proxy);
		[entry("FMOD_System_GetProxy")]
		enum FMOD_RESULT _cdecl GetProxy (int System, char *proxy, int proxylen);

		[entry("FMOD_System_SetUserData")]
		enum FMOD_RESULT _cdecl SetUserData (int System, int userdata);
		[entry("FMOD_System_GetUserData")]
		enum FMOD_RESULT _cdecl GetUserData (int System, int userdata_ptr);
	}

	[dllname("FModEX.DLL")]
	module Sound {

		[entry("FMOD_Sound_Release")]
		enum FMOD_RESULT _cdecl Release (int Sound);
		[entry("FMOD_Sound_GetSystemObject")]
		enum FMOD_RESULT _cdecl GetSystemObject (int Sound, int System);

		[entry("FMOD_Sound_Lock")]
		enum FMOD_RESULT _cdecl Lock (int Sound, int offset, int length, [out] int *ptr1, [out] int *ptr2, [out] int *len1, [out] int *len2);
		[entry("FMOD_Sound_Unlock")]
		enum FMOD_RESULT _cdecl Unlock (int Sound, int ptr1, int ptr2, int len1, int len2);
		[entry("FMOD_Sound_SetDefaults")]
		enum FMOD_RESULT _cdecl SetDefaults (int Sound, int frequency, int volume, int pan, int *levels, int priority, int weight);
		[entry("FMOD_Sound_GetDefaults")]
		enum FMOD_RESULT _cdecl GetDefaults (int Sound, [out] int *frequency, [out] int *volume, [out] int *pan, [out] int *levels, [out] int *priority, [out] int *weight);
		[entry("FMOD_Sound_SetVariations")]
		enum FMOD_RESULT _cdecl SetVariations (int Sound, int frequency, int volume, int pan);
		[entry("FMOD_Sound_GetVariations")]
		enum FMOD_RESULT _cdecl GetVariations (int Sound, [out] int *frequency, [out] int *volume, [out] int *pan);
		[entry("FMOD_Sound_Set3DMinMaxDistance")]
		enum FMOD_RESULT _cdecl Set3DMinMaxDistance (int Sound, float min, float max);
		[entry("FMOD_Sound_Get3DMinMaxDistance")]
		enum FMOD_RESULT _cdecl Get3DMinMaxDistance (int Sound, [out] float *min, [out] float *max);
		[entry("FMOD_Sound_SetSubSound")]
		enum FMOD_RESULT _cdecl SetSubSound (int Sound, int index, int subSound);
		[entry("FMOD_Sound_GetSubSound")]
		enum FMOD_RESULT _cdecl GetSubSound (int Sound, int index, [out] int *subSound);
		[entry("FMOD_Sound_GetName")]
		enum FMOD_RESULT _cdecl GetName (int Sound, [out, string] char *name, int namelen);
		[entry("FMOD_Sound_GetLength")]
		enum FMOD_RESULT _cdecl GetLength (int Sound, [out] int *lengthpcm, [out] int *lengthms, [out] int *lengthbytes);
		[entry("FMOD_Sound_GetFormat")]
		enum FMOD_RESULT _cdecl GetFormat (int Sound, [out] enum FMOD_SOUND_TYPE *type, [out] enum FMOD_SOUND_FORMAT *format, [out] int *Channels);
		[entry("FMOD_Sound_GetNumSubSounds")]
		enum FMOD_RESULT _cdecl GetNumSubSounds (int Sound, [out] int *numsubSounds);
		[entry("FMOD_Sound_GetNumTags")]
		enum FMOD_RESULT _cdecl GetNumTags (int Sound, [out] int *numtags, [out] int *numtagsupdated);
		[entry("FMOD_Sound_GetTag")]
		enum FMOD_RESULT _cdecl GetTag (int Sound, [string] const char *name, int index, [out] struct FMOD_TAG *tag);
		[entry("FMOD_Sound_GetOpenState")]
		enum FMOD_RESULT _cdecl GetOpenState (int Sound, [out] enum FMOD_OPENSTATE *openstate);
		[entry("FMOD_Sound_ReadData")]
		enum FMOD_RESULT _cdecl ReadData (int Sound, [out] void *buffer, int lenbytes, [out] int *read);
		[entry("FMOD_Sound_SeekData")]
		enum FMOD_RESULT _cdecl SeekData (int Sound, int pcm);

		[entry("FMOD_Sound_SetMode")]
		enum FMOD_RESULT _cdecl SetMode (int Sound, enum FMOD_MODE mode);
		[entry("FMOD_Sound_GetMode")]
		enum FMOD_RESULT _cdecl GetMode (int Sound, [out] enum FMOD_MODE *mode);
		[entry("FMOD_Sound_SetLoopCount")]
		enum FMOD_RESULT _cdecl SetLoopCount (int Sound, int loopcount);
		[entry("FMOD_Sound_GetLoopCount")]
		enum FMOD_RESULT _cdecl GetLoopCount (int Sound, [out] int *loopcount);
		[entry("FMOD_Sound_SetLoopPoints")]
		enum FMOD_RESULT _cdecl SetLoopPoints (int Sound, int loopstart, int loopend);
		[entry("FMOD_Sound_GetLoopPoints")]
		enum FMOD_RESULT _cdecl GetLoopPoints (int Sound, [out] int *loopstart, [out] int *loopend);

		[entry("FMOD_Sound_SetUserData")]
		enum FMOD_RESULT _cdecl SetUserData (int Sound, void *userdata);
		[entry("FMOD_Sound_GetUserData")]
		enum FMOD_RESULT _cdecl GetUserData (int Sound, [out] int *userdata);

	}

	[dllname("FModEX.DLL")]
	module Channel {

		[entry("FMOD_Channel_GetSystemObject")]
		enum FMOD_RESULT _cdecl GetSystemObject (int Channel, [out] int *systemsystem);

		[entry("FMOD_Channel_Stop")]
		enum FMOD_RESULT _cdecl Stop (int Channel);
		[entry("FMOD_Channel_SetPaused")]
		enum FMOD_RESULT _cdecl SetPaused (int Channel, int paused);
		[entry("FMOD_Channel_GetPaused")]
		enum FMOD_RESULT _cdecl GetPaused (int Channel, int *paused);
		[entry("FMOD_Channel_SetVolume")]
		enum FMOD_RESULT _cdecl SetVolume (int Channel, int volume);
		[entry("FMOD_Channel_GetVolume")]
		enum FMOD_RESULT _cdecl GetVolume (int Channel, int *volume);
		[entry("FMOD_Channel_SetFrequency")]
		enum FMOD_RESULT _cdecl SetFrequency (int Channel, int frequency);
		[entry("FMOD_Channel_GetFrequency")]
		enum FMOD_RESULT _cdecl GetFrequency (int Channel, int *frequency);
		[entry("FMOD_Channel_SetPan")]
		enum FMOD_RESULT _cdecl SetPan (int Channel, int lrpan, int fbpan);
		[entry("FMOD_Channel_GetPan")]
		enum FMOD_RESULT _cdecl GetPan (int Channel, int *lrpan, int *fbpan);
		[entry("FMOD_Channel_SetSpeakerLevels")]
		enum FMOD_RESULT _cdecl SetSpeakerLevels (int Channel, int *levels, int numlevels);
		[entry("FMOD_Channel_GetSpeakerLevels")]
		enum FMOD_RESULT _cdecl GetSpeakerLevels (int Channel, int *levels, int *numlevels);
		[entry("FMOD_Channel_SetMute")]
		enum FMOD_RESULT _cdecl SetMute (int Channel, int mute);
		[entry("FMOD_Channel_GetMute")]
		enum FMOD_RESULT _cdecl GetMute (int Channel, int *mute);
		[entry("FMOD_Channel_SetPriority")]
		enum FMOD_RESULT _cdecl SetPriority (int Channel, int priority);
		[entry("FMOD_Channel_GetPriority")]
		enum FMOD_RESULT _cdecl GetPriority (int Channel, int *priority);
		[entry("FMOD_Channel_SetWeight")]
		enum FMOD_RESULT _cdecl SetWeight (int Channel, int weight);
		[entry("FMOD_Channel_GetWeight")]
		enum FMOD_RESULT _cdecl GetWeight (int Channel, int *weight);
		[entry("FMOD_Channel_Set3DAttributes")]
		enum FMOD_RESULT _cdecl Set3DAttributes (int Channel, const struct FMOD_VECTOR *pos, const struct FMOD_VECTOR *vel);
		[entry("FMOD_Channel_Get3DAttributes")]
		enum FMOD_RESULT _cdecl Get3DAttributes (int Channel, [out] struct FMOD_VECTOR *pos, [out] struct FMOD_VECTOR *vel);
		[entry("FMOD_Channel_Set3DMinMaxDistance")]
		enum FMOD_RESULT _cdecl Set3DMinMaxDistance (int Channel, float mindistance, float maxdistance);
		[entry("FMOD_Channel_Get3DMinMaxDistance")]
		enum FMOD_RESULT _cdecl Get3DMinMaxDistance (int Channel, float *mindistance, float *maxdistance);
		[entry("FMOD_Channel_SetReverbProperties")]
		enum FMOD_RESULT _cdecl SetReverbProperties (int Channel, const struct FMOD_REVERB_CHANNELPROPERTIES *prop);
		[entry("FMOD_Channel_GetReverbProperties")]
		enum FMOD_RESULT _cdecl GetReverbProperties (int Channel, [out] struct FMOD_REVERB_CHANNELPROPERTIES *prop);
		[entry("FMOD_Channel_SetVolumeAbsolute")]
		enum FMOD_RESULT _cdecl SetVolumeAbsolute (int Channel, int volume);
		[entry("FMOD_Channel_IsPlaying")]
		enum FMOD_RESULT _cdecl IsPlaying (int Channel, [out] int *isplaying);
		[entry("FMOD_Channel_GetCurrentSound")]
		enum FMOD_RESULT _cdecl GetCurrentSound (int Channel, [out] int *sound);
		[entry("FMOD_Channel_GetSpectrum")]
		enum FMOD_RESULT _cdecl GetSpectrum (int Channel, [out] float *spectrum, int numentries, int latencyadjusted);
		[entry("FMOD_Channel_GetLevels")]
		enum FMOD_RESULT _cdecl GetLevels (int Channel, [out] int *levels, [out] int *numlevels, int latencyadjusted);
		[entry("FMOD_Channel_SetCallback")]
		enum FMOD_RESULT _cdecl SetCallback (int Channel, enum FMOD_CHANNEL_CALLBACK_TYPE type, int evdata, int Channel_callback);
		[entry("FMOD_Channel_SetPosition")]
		enum FMOD_RESULT _cdecl SetPosition (int Channel, int pcm, int nonblocking);
		[entry("FMOD_Channel_GetPosition")]
		enum FMOD_RESULT _cdecl GetPosition (int Channel, [out] int *pcm, int latencyadjusted);
		[entry("FMOD_Channel_SetTime")]
		enum FMOD_RESULT _cdecl SetTime (int Channel, int ms, int nonblocking);
		[entry("FMOD_Channel_GetTime")]
		enum FMOD_RESULT _cdecl GetTime (int Channel, [out] int *ms, int latencyadjusted);
		[entry("FMOD_Channel_GetDSPHead")]
		enum FMOD_RESULT _cdecl GetDSPHead (int Channel, [out] int *dsp);

		[entry("FMOD_Channel_SetMode")]
		enum FMOD_RESULT _cdecl SetMode (int Channel, enum FMOD_MODE mode);
		[entry("FMOD_Channel_GetMode")]
		enum FMOD_RESULT _cdecl GetMode (int Channel, [out] enum FMOD_MODE *mode);
		[entry("FMOD_Channel_SetLoopCount")]
		enum FMOD_RESULT _cdecl SetLoopCount (int Channel, int loopcount);
		[entry("FMOD_Channel_GetLoopCount")]
		enum FMOD_RESULT _cdecl GetLoopCount (int Channel, [out] int *loopcount);
		[entry("FMOD_Channel_SetLoopPoints")]
		enum FMOD_RESULT _cdecl SetLoopPoints (int Channel, int loopstart, int loopend);
		[entry("FMOD_Channel_GetLoopPoints")]
		enum FMOD_RESULT _cdecl GetLoopPoints (int Channel, [out] int *loopstart, [out] int *loopend);

		[entry("FMOD_Channel_SetUserData")]
		enum FMOD_RESULT _cdecl SetUserData (int Channel, void *userdata);
		[entry("FMOD_Channel_GetUserData")]
		enum FMOD_RESULT _cdecl GetUserData (int Channel, [out] int *userdata);

	}

	/*
	[dllname("FModEX.DLL"),
		helpstring("")
	]
	module  {
	}
	*/

}
